= _Microservices_ Design Patterns for _Java Applications_
////
Microservices allow to decompose a monolithic application into cohesive and multiple decoupled services. Each service is running in its own process and communicates using lightweight mechanisms, such as HTTP API. These services are built around business capabilities or functional decomposition. Microservice also enables true polyglot architecture - both in terms of language and data. It truly allows you to employ the right tool for the right job. Each service is independently deployable and lends very well to fully automated deployment machinery.

Can you take an existing Java EE application and decompose it into microservices? What tools are required to enable CI/CD? What are different design patterns for microservices? What tools do you need to manage such services? Is the complexity being pushed around from service implementation to orchestration?
This talk will explain some of these concerns and provide guidance on how to leverage microservices in your Java applications.
////
Vineet Reynolds; Red Hat
:license: CC BY-SA 4.0
include::attributes.adoc[]

[.topic.intro]
== Who am I ?

== !

*What does this talk cover ?*

[.incremental]
* MicroServices - a brief introduction
 ** The monolith
 ** Decomposing monoliths
* Composing microservices
 ** Aggregator
 ** Proxy
 ** Chained services
 ** Branch
 ** Shared data
 ** Asychronous messaging

[.topic.source]
== The monolith

image::monolith-internals.png[Internals of a monolith,480,role="middle"]

[.topic.source]
== The monolith

image::monolith-deployment.png[Deploying monoliths,480,role="middle"]

[.topic.source]
== The monolith

* Do they have *advantages* ? Oh, yes.
 ** Packaged and deployed as a single unit. Relative ease of rolling back from failure.
 ** Homogenous design - could be a good thing to counter chaos.
 ** Easy to test - services are always available.
 ** Simple to develop - single codebase.
 ** Easy to scale horizontally.
 ** Organize operations around a single team.

[.topic.source]
== The monolith

* Do they have *disadvantages* ? Oh, yes, a lot more.
 ** Long deployment cycles (lasting hours or even days)
 ** May not use the right framework/tool/language for each domain
 ** Acquires too many responsibility over time

[.topic.source]
== Microservices

Characteristics

* Many smaller (fine grained), clearly scoped services
 ** Single Responsibility Principle (`S` in `SOLID`, but for services)
 ** Independently managed
* Clear ownership for each service
 ** Independently deployable, leading easily to CI+CD
 ** Typically need/adopt the "DevOps" model


[.topic.source]
== What are Microservices?

* Hipster SOA?
* Fine-grained SOA?
* Focus on ESBs in SOA?
* SOA done right?

[.topic.source]
== Decomposing the monolith into services

* Verb or usecase - e.g. Checkout UI
* Noun - e.g. Catalog product service
* Single Responsible Principle - e.g. Unix utilities

[.topic.source]
== Aggregator

image::microservices-aggregator-1024x528.png[Aggregator,480,role="middle"]

[.topic.source]
== Proxy

image::microservices-proxy-1024x525.png[Aggregator,480,role="middle"]

[.topic.source]
== Chained services

image::microservices-chain-1024x575.png[Aggregator,480,role="middle"]

[.topic.source]
== Branch

image::microservices-branch-1024x639.png[Branch,480,role="middle"]

[.topic.source]
== Shared data

image::microservices-branch-shared-data-1024x634.png[Shared data,480,role="middle"]

[.topic.source]
== Asynchronous messaging

image::microservices-async-messaging-1024x640.png[Asynchronous messaging,480,role="middle"]

[.topic.ending, hrole="name"]
== !

[.footer]
Questions?